{"code":"import { isObject } from \"@vue/shared\";\nimport { mutableHandlers, shallowReactiveHandlers, readonlyHandlers, shallowReadonlyHandlers } from \"./baseHandlers\";\nexport function reactive(target) {\n    return createReactiveObject(target, false, mutableHandlers);\n}\nexport function shallowReactive(target) {\n    return createReactiveObject(target, false, shallowReactiveHandlers);\n}\nexport function readonly(target) {\n    return createReactiveObject(target, true, readonlyHandlers);\n}\nexport function shallowReadonly(target) {\n    return createReactiveObject(target, true, shallowReadonlyHandlers);\n}\n// 是不是仅读，是不是深度，是不是柯里化 new Proxy () 最核心的需要拦截，数据的读取和数据的修改\nconst reactiveMap = new WeakMap(); //会自动垃圾回收，不会造成内存泄露，存储的key只能是对象\nconst readonlyMap = new WeakMap();\nexport function createReactiveObject(target, isReadonly, baseHandlers) {\n    // 如果目标不是对象 没法拦截了reactive 这个api只能拦截对象类型\n    if (isObject(target)) {\n        return target;\n    }\n    // 如果某个对象已经代理过了 就不代理 可能一个对象 被代理是深度， 又仅读代理\n    const proxyMap = isReadonly ? readonlyMap : reactiveMap;\n    const exisitProxy = proxyMap.get(target);\n    if (exisitProxy) {\n        return exisitProxy;\n    }\n    const proxy = new Proxy(target, baseHandlers);\n    proxyMap.set(target, proxy); //将要代理的对象和对应代理结果缓存起来\n    return proxy;\n}\n","references":["D:/学习/学习计划/Study-Vue3/vue3/packages/shared/src/index.ts","D:/学习/学习计划/Study-Vue3/vue3/packages/reactivity/src/baseHandlers.ts"]}
